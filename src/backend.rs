use iced::futures::SinkExt;
use iced::futures::channel::mpsc::Sender;
use pipewire as pw;
use pw::{properties::properties, spa};
use realfft::RealFftPlanner;
use spa::param::format::{MediaSubtype, MediaType};
use spa::param::format_utils;
use spa::pod::Pod;
use std::collections::VecDeque;
use std::convert::TryInto;
use std::f32::consts::PI;
use std::mem;
use std::slice::Chunks;
use std::sync::mpsc::{Sender as StdSender, channel};

pub const FFT_SIZE: usize = 8192;

#[derive(Debug, Clone)]
pub struct AudioInfo {
    rate: u32,
    channels: u32,
}

impl AudioInfo {
    pub fn rate(&self) -> u32 {
        self.rate
    }
    pub fn channels(&self) -> u32 {
        self.channels
    }
}

#[derive(Debug, Clone)]
pub enum PwEvent {
    FormatChange(AudioInfo),
    DataNew(Matrix<f32>),
    Spectrum(Vec<f32>),
    PwErr,
}

struct UserData {
    format: spa::param::audio::AudioInfoRaw,
    sender: StdSender<PwEvent>,
    spectrum_data: VecDeque<f32>,
}

pub fn apply_blackman_harris(block: &mut [f32]) {
    let n = block.len().saturating_sub(1) as f32;
    if n <= 0.0 {
        return;
    }

    for (i, sample) in block.iter_mut().enumerate() {
        let k = i as f32 / n;
        let window = 0.01168f32.mul_add(
            -(6.0 * PI * k).cos(),
            0.14128f32.mul_add(
                (4.0 * PI * k).cos(),
                0.48829f32.mul_add(-(2.0 * PI * k).cos(), 0.35875),
            ),
        );
        *sample *= window;
    }
}

impl UserData {
    fn append_spectrum(&mut self, datas: &[f32]) {
        for data in datas {
            self.spectrum_data.push_back(*data);
            self.spectrum_data.pop_front();
        }
    }
    fn send_spectrum(&self) {
        let mut block: Vec<f32> = self.spectrum_data.iter().copied().collect();
        let mut planner: RealFftPlanner<f32> = RealFftPlanner::new();
        let fft = planner.plan_fft_forward(FFT_SIZE);
        apply_blackman_harris(&mut block);
        let mut spectrum = fft.make_output_vec();
        if fft.process(&mut block, &mut spectrum).is_ok() {
            let data: Vec<f32> = spectrum.iter().map(|v| v.norm()).collect();
            let _ = self.sender.send(PwEvent::Spectrum(data));
        }
    }
}

pub fn listen_pw() -> iced::Subscription<PwEvent> {
    iced::Subscription::run(|| {
        iced::stream::channel(100, |mut output: Sender<PwEvent>| async move {
            let (sync_sender, sync_receiver) = channel();
            std::thread::spawn(move || {
                connect(sync_sender);
            });
            loop {
                let Ok(data) = sync_receiver.recv() else {
                    let _ = output.send(PwEvent::PwErr).await;
                    break;
                };
                let _ = output.send(data).await;
            }
        })
    })
}

#[derive(Debug, Clone)]
pub struct MatrixFixed<T = f32>
where
    T: Clone + Copy + Default,
{
    inner: Vec<VecDeque<T>>,
    len: usize,
    channel: usize,
}

impl<T> MatrixFixed<T>
where
    T: Clone + Copy + Default,
{
    pub fn new(len: usize, channel: usize) -> Self {
        Self {
            inner: vec![vec![Default::default(); len].into(); channel],
            len,
            channel,
        }
    }
    pub fn channel(&self) -> usize {
        self.channel
    }
    pub fn len(&self) -> usize {
        self.len
    }
    pub fn data(&self) -> &[VecDeque<T>] {
        self.inner.as_slice()
    }
    pub fn append(&mut self, matrix: Matrix<T>) {
        assert_eq!(matrix.channel(), self.channel());
        let chunks = matrix.chunks(1);
        for chunk in chunks {
            for (data, channel_data) in chunk.iter().zip(&mut self.inner) {
                channel_data.push_back(data[0]);
                channel_data.pop_front();
            }
        }
    }
}

#[derive(Debug, Clone)]
pub struct Matrix<T = f32>
where
    T: Clone + Copy,
{
    inner: Vec<Vec<T>>,
}

struct MatrixChunks<'a, T>
where
    T: Clone + Copy,
{
    inner: Vec<Chunks<'a, T>>,
}

impl<'a, T> Iterator for MatrixChunks<'a, T>
where
    T: Clone + Copy,
{
    type Item = Vec<&'a [T]>;
    fn next(&mut self) -> Option<Self::Item> {
        let mut outputs = vec![];
        for chunk in &mut self.inner {
            let data = chunk.next()?;
            outputs.push(data);
        }
        Some(outputs)
    }
}

impl<T> Matrix<T>
where
    T: Clone + Copy,
{
    fn init(inner: Vec<Vec<T>>) -> Self {
        Self { inner }
    }
    fn channel(&self) -> usize {
        self.inner.len()
    }
    fn chunks<'a>(&'a self, chunk_size: usize) -> MatrixChunks<'a, T> {
        let mut chunks = vec![];
        for data in &self.inner {
            chunks.push(data.chunks(chunk_size));
        }
        MatrixChunks { inner: chunks }
    }
}

fn connect(sender: StdSender<PwEvent>) {
    if let Err(_) = connect_inner(sender.clone()) {
        let _ = sender.send(PwEvent::PwErr);
    }
}

fn connect_inner(sender: StdSender<PwEvent>) -> Result<(), pw::Error> {
    pw::init();

    let mainloop = pw::main_loop::MainLoopRc::new(None)?;
    let context = pw::context::ContextRc::new(&mainloop, None)?;
    let core = context.connect_rc(None)?;

    let data = UserData {
        format: Default::default(),
        sender,
        spectrum_data: VecDeque::with_capacity(FFT_SIZE),
    };

    /* Create a simple stream, the simple stream manages the core and remote
     * objects for you if you don't need to deal with them.
     *
     * If you plan to autoconnect your stream, you need to provide at least
     * media, category and role properties.
     *
     * Pass your events and a user_data pointer as the last arguments. This
     * will inform you about the stream state. The most important event
     * you need to listen to is the process event where you need to produce
     * the data.
     */
    let props = properties! {
        *pw::keys::MEDIA_TYPE => "Audio",
        *pw::keys::MEDIA_CATEGORY => "Capture",
        *pw::keys::MEDIA_ROLE => "Music",
        *pw::keys::STREAM_CAPTURE_SINK => "true",
    };

    // uncomment if you want to capture from the sink monitor ports
    // props.insert(*pw::keys::STREAM_CAPTURE_SINK, "true");

    let stream = pw::stream::StreamBox::new(&core, "audio-capture", props)?;

    let _listener = stream
        .add_local_listener_with_user_data(data)
        .param_changed(|_, user_data, id, param| {
            // NULL means to clear the format
            let Some(param) = param else {
                return;
            };
            if id != pw::spa::param::ParamType::Format.as_raw() {
                return;
            }

            let (media_type, media_subtype) = match format_utils::parse_format(param) {
                Ok(v) => v,
                Err(_) => return,
            };

            // only accept raw audio
            if media_type != MediaType::Audio || media_subtype != MediaSubtype::Raw {
                return;
            }

            // call a helper function to parse the format for us.
            user_data
                .format
                .parse(param)
                .expect("Failed to parse param changed to AudioInfoRaw");

            let _ = user_data.sender.send(PwEvent::FormatChange(AudioInfo {
                rate: user_data.format.rate(),
                channels: user_data.format.channels(),
            }));
            println!(
                "capturing rate:{} channels:{}",
                user_data.format.rate(),
                user_data.format.channels()
            );
        })
        .process(|stream, user_data| match stream.dequeue_buffer() {
            None => println!("out of buffers"),
            Some(mut buffer) => {
                let datas = buffer.datas_mut();
                if datas.is_empty() {
                    return;
                }

                let data = &mut datas[0];
                let n_channels = user_data.format.channels();
                let n_samples = data.chunk().size() / (mem::size_of::<f32>() as u32);

                let Some(samples) = data.data() else {
                    return;
                };
                let mut matrix_inner =
                    vec![vec![0.; (n_samples / n_channels) as usize]; n_channels as usize];
                for c in 0..n_channels {
                    for (index, n) in (c..n_samples).step_by(n_channels as usize).enumerate() {
                        let start = n as usize * mem::size_of::<f32>();
                        let end = start + mem::size_of::<f32>();
                        let chan = &samples[start..end];
                        let f = f32::from_le_bytes(chan.try_into().unwrap());
                        matrix_inner[c as usize][index] = f;
                    }
                }
                user_data.append_spectrum(&matrix_inner[0]);
                let matrix = Matrix {
                    inner: matrix_inner,
                };
                for data in matrix.chunks(80) {
                    let data_new: Vec<Vec<f32>> = data
                        .iter()
                        .map(|data| data.iter().copied().collect())
                        .collect();
                    let data_chunk: Matrix<f32> = Matrix::init(data_new);
                    let _ = user_data.sender.send(PwEvent::DataNew(data_chunk));
                }
            }
        })
        .register()?;

    /* Make one parameter with the supported formats. The SPA_PARAM_EnumFormat
     * id means that this is a format enumeration (of 1 value).
     * We leave the channels and rate empty to accept the native graph
     * rate and channels. */
    let mut audio_info = spa::param::audio::AudioInfoRaw::new();
    audio_info.set_format(spa::param::audio::AudioFormat::F32LE);
    let obj = pw::spa::pod::Object {
        type_: pw::spa::utils::SpaTypes::ObjectParamFormat.as_raw(),
        id: pw::spa::param::ParamType::EnumFormat.as_raw(),
        properties: audio_info.into(),
    };
    let values: Vec<u8> = pw::spa::pod::serialize::PodSerializer::serialize(
        std::io::Cursor::new(Vec::new()),
        &pw::spa::pod::Value::Object(obj),
    )
    .unwrap()
    .0
    .into_inner();

    let mut params = [Pod::from_bytes(&values).unwrap()];

    /* Now connect this stream. We ask that our process function is
     * called in a realtime thread. */
    stream.connect(
        spa::utils::Direction::Input,
        None,
        pw::stream::StreamFlags::AUTOCONNECT
            | pw::stream::StreamFlags::MAP_BUFFERS
            | pw::stream::StreamFlags::RT_PROCESS,
        &mut params,
    )?;

    // and wait while we let things run
    mainloop.run();
    Ok(())
}
